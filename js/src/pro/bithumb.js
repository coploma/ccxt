// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code
// EDIT THE CORRESPONDENT .ts FILE INSTEAD

//  ---------------------------------------------------------------------------
import bithumbRest from '../bithumb.js';
import { ArrayCache } from '../base/ws/Cache.js';
//  ---------------------------------------------------------------------------
export default class bithumb extends bithumbRest {
    describe() {
        return this.deepExtend(super.describe(), {
            'has': {
                'ws': true,
                'watchOrderBook': true,
                'watchOrderBookForSymbols': true,
                'watchTicker': true,
                'watchTrades': true,
                'watchTradesForSymbols': true,
            },
            'urls': {
                'api': {
                    'ws': 'wss://pubwss.bithumb.com/pub/ws',
                },
            },
            'options': {
                'tradesLimit': 1000,
            },
        });
    }
    async watchPublic(symbol, channel, params = {}) {
        await this.loadMarkets();
        const market = this.market(symbol);
        const marketId = market['id'];
        const url = this.urls['api']['ws'];
        const tickTypes = this.safeValue(params, 'tickTypes');
        const request = {
            'type': channel,
            'symbols': [`${marketId}_KRW`],
        };
        if (tickTypes !== undefined) {
            request['tickTypes'] = tickTypes;
        }
        const messageHash = channel + ':' + marketId;
        return await this.watch(url, messageHash, request, messageHash);
    }

    async watchPublicMultiple(symbols, channel, params = {}) {
        await this.loadMarkets();
        const symbolsArg = [];
        const messageHashes = [];
        for (let i = 0; i < symbols.length; i++) {
            const symbol = symbols[i];
            const market = this.market(symbol);
            const marketId = market['id'];
            symbolsArg.push(`${marketId}_KRW`);
            messageHashes.push(channel + ':' + marketId);
        }
        const url = this.urls['api']['ws'];
        const tickTypes = this.safeValue(params, 'tickTypes');
        const request = {
            'type': channel,
            'symbols': symbolsArg,
        };
        if (tickTypes !== undefined) {
            request['tickTypes'] = tickTypes;
        }
        return await this.watchMultiple(url, messageHashes, request, messageHashes);
    }

    async watchTicker(symbol, params = {}) {
        /**
         * @method
         * @name bithumb#watchTicker
         * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
         * @param {string} symbol unified symbol of the market to fetch the ticker for
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
         */
        const tickTypes = this.safeValue(params, 'tickTypes', ['24H']);
        return await this.watchPublic(symbol, 'ticker', { tickTypes });
    }
    async watchTrades(symbol, since = undefined, limit = undefined, params = {}) {
        /**
         * @method
         * @name bithumb#watchTrades
         * @description get the list of most recent trades for a particular symbol
         * @param {string} symbol unified symbol of the market to fetch trades for
         * @param {int} [since] timestamp in ms of the earliest trade to fetch
         * @param {int} [limit] the maximum amount of trades to fetch
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
         */
        return await this.watchTradesForSymbols([symbol], since, limit, params);
    }
    async watchTradesForSymbols(symbols = undefined, since = undefined, limit = undefined, params = {}) {
        const trades = await this.watchPublicMultiple(symbols, 'transaction');
        if (this.newUpdates) {
            limit = trades.getLimit(symbol, limit);
        }
        return this.filterBySinceLimit(trades, since, limit, 'timestamp', true);
    }
    async watchOrderBook(symbol, limit = undefined, params = {}) {
        /**
         * @method
         * @name bithumb#watchOrderBook
         * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         * @param {string} symbol unified symbol of the market to fetch the order book for
         * @param {int} [limit] the maximum amount of order book entries to return
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
         */
        return await this.watchOrderBookForSymbols([symbol], limit, params);
    }

    async watchOrderBookForSymbols(symbols = undefined, limit = undefined, params = {}) {
        const orderBook = await this.watchPublicMultiple(symbols, 'orderbooksnapshot');
        return orderBook.limit();
    }
    handleTicker(client, message) {
        // {
        //     "type" : "ticker",
        //     "content" : {
        //         "symbol" : "BTC_KRW",			// 통화 코드
        //         "tickType" : "24H",					// 변동 기준시간- 30M, 1H, 12H, 24H, MID
        //         "date" : "20200129",				// 일자
        //         "time" : "121844",					// 시간
        //         "openPrice" : "2302",				// 시가
        //         "closePrice" : "2317",				// 종가
        //         "lowPrice" : "2272",				// 저가
        //         "highPrice" : "2344",				// 고가
        //         "value" : "2831915078.07065789",	// 누적 거래 금액
        //         "volume" : "1222314.51355788",	// 누적 거래량
        //         "sellVolume" : "760129.34079004",	// 매도 누적 거래량
        //         "buyVolume" : "462185.17276784",	// 매수 누적 거래량
        //         "prevClosePrice" : "2326",			// 전일 종가
        //         "chgRate" : "0.65",					// 변동률
        //         "chgAmt" : "15",					// 변동금액
        //         "volumePower" : "60.80"			// 체결 강도
        //     }
        // }
        let content = this.safeValue(message, "content");
        const marketId = this.safeString(message, 'symbol').replace('_KRW', '');
        const messageHash = 'ticker:' + marketId;
        content = {
            'date' : this.safeString(message, 'date'),
            'opening_price' : this.safeFloat(message, 'openPrice'),
            'closing_price' : this.safeFloat(message, 'closePrice'),
            'units_traded_24H' : this.safeFloat(message, 'volume'),
            'acc_trade_value_24H' : this.safeFloat(message, 'value'),
            'max_price': this.safeFloat(message, 'highPrice'),
            'min_price': this.safeFloat(message, 'lowPrice'),
        }
        const ticker = this.parseTicker(content, marketId);
        const symbol = ticker['symbol'];
        this.tickers[symbol] = ticker;
        client.resolve(ticker, messageHash);
    }
    handleOrderBookSnapshot(client, message) {
        // {
        //     "type": "orderbooksnapshot",
        //     "content": {			// 매수, 매도 30호가 제공
        //         "symbol": "BTC_KRW",
        //         "datetime": "1680082623245840",
        //         "asks": [
        //             [
        //                 "37458000",	// 호가
        //                 "0.9986"	// 잔량
        //             ],
        //             ["37461000","0.0487"],
        //             ["37462000","0.9896"],
        //             ["37464000","0.2296"],
        //             ["37466000","0.1075"]
        //         ],
        //         "bids": [
        //             [
        //                 "37452000",
        //                 "0.0115"
        //             ],
        //             ["37450000","0.0614"],
        //             ["37448000","0.0991"],
        //             ["37447000","0.0002"],
        //             ["37445000","0.1249"]
        //         ]
        //     }
        // }
        const content = this.safeValue(message, "content");
        const marketId = this.safeString(content, 'symbol').replace('_KRW', '');
        const symbol = this.safeSymbol(marketId);
        const messageHash = 'orderbooksnapshot:' + marketId;
        const timestamp = this.safeInteger(content, 'datetime') / 1000;
        const snapshot = this.parseOrderBook(content, symbol, timestamp, 'bids', 'asks', 0, 1);
        let orderbook = this.safeValue(this.orderbooks, symbol);
        const limit = this.safeInteger(this.options, 'ordersLimit', 1000);
        if (orderbook === undefined) {
            orderbook = this.orderBook({}, limit);
            orderbook['symbol'] = symbol;
        }
        orderbook.reset(snapshot);
        // unroll the accumulated deltas
        const cachedData = orderbook.cache;
        for (let i = 0; i < cachedData.length; i++) {
            const data = cachedData[i];
            this.handleOrderBookMessage(client, data, orderbook);
        }
        this.orderbooks[symbol] = orderbook;
        client.resolve(orderbook, messageHash);
    }
    handleOrderBook(client, message) {
        // {
        //     "type" : "orderbookdepth",
        //         "content" : {
        //         "list" : [
        //             {
        //                 "symbol" : "BTC_KRW",
        //                 "orderType" : "ask",		// 주문 타입 – bid / ask
        //                 "price" : "10593000",		// 호가
        //                 "quantity" : "1.11223318",	// 잔량
        //                 "total" : "3"				// 건수
        //             },
        //             {"symbol" : "BTC_KRW", "orderType" : "ask", "price" : "10596000", "quantity" : "0.5495", "total" : "8"},
        //             {"symbol" : "BTC_KRW", "orderType" : "ask", "price" : "10598000", "quantity" : "18.2085", "total" : "10"},
        //             {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10532000", "quantity" : "0", "total" : "0"},
        //             {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10572000", "quantity" : "2.3324", "total" : "4"},
        //             {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10571000", "quantity" : "1.469", "total" : "3"},
        //             {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10569000", "quantity" : "0.5152", "total" : "2"}
        //         ],
        //         "datetime":1580268255864325		// 일시
        //     }
        // }
        const content = this.safeValue(message, "content");
        const data = this.safeValue(content, 'list');
        const marketId = this.safeString(content, 'symbol').replace('_KRW', '');
        const symbol = this.safeSymbol(marketId);
        const timestamp = this.safeInteger(content, 'datetime') / 1000;
        const messageHash = "orderbookdelta" + ':' + marketId;
        const limit = this.safeInteger(this.options, 'ordersLimit', 1000);
        let orderbook = this.safeValue(this.orderbooks, symbol);
        if (orderbook === undefined) {
            orderbook = this.orderBook({}, limit);
            orderbook['symbol'] = symbol;
        }
        if (orderbook['timestamp'] === undefined) {
            orderbook.cache.push(data);
        }
        else {
            this.handleOrderBookMessage(symbol, timestamp, data, orderbook);
            client.resolve(orderbook, messageHash);
        }
    }
    handleDelta(bookside, delta) {
        //
        // {"symbol" : "BTC_KRW", "orderType" : "ask", "price" : "10596000", "quantity" : "0.5495", "total" : "8"}
        //
        const price = this.safeNumber(delta, "price");
        const amount = this.safeNumber(delta, "quantity");
        bookside.store(price, amount);
    }
    handleOrderBookMessage(timestamp, data, orderbook) {
        // [
        //     {
        //         "symbol" : "BTC_KRW",
        //         "orderType" : "ask",		// 주문 타입 – bid / ask
        //         "price" : "10593000",		// 호가
        //         "quantity" : "1.11223318",	// 잔량
        //         "total" : "3"				// 건수
        //     },
        //     {"symbol" : "BTC_KRW", "orderType" : "ask", "price" : "10596000", "quantity" : "0.5495", "total" : "8"},
        //     {"symbol" : "BTC_KRW", "orderType" : "ask", "price" : "10598000", "quantity" : "18.2085", "total" : "10"},
        //     {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10532000", "quantity" : "0", "total" : "0"},
        //     {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10572000", "quantity" : "2.3324", "total" : "4"},
        //     {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10571000", "quantity" : "1.469", "total" : "3"},
        //     {"symbol" : "BTC_KRW", "orderType" : "bid", "price" : "10569000", "quantity" : "0.5152", "total" : "2"}
        // ]
        if (timestamp > orderbook['timestamp']) {
            for (let i = 0; i < data.length; i++) {
                const delta = data[i];
                const side = this.safeString(delta, 'orderType');
                const bookside = (side === 'ask') ? orderbook['asks'] : orderbook['bids'];
                this.handleDelta(bookside, delta);
            }
            orderbook['timestamp'] = timestamp;
            orderbook['datetime'] = this.iso8601(timestamp);
        }
        return orderbook;
    }
    handleTrades(client, message) {
        // {
        //     "type" : "transaction",
        //     "content" : {
        //         "list" : [
        //             {
        //                 "symbol" : "BTC_KRW",					// 통화 코드
        //                 "buySellGb" : "1",							// 체결 종류(1:매도체결, 2:매수체결)
        //                 "contPrice" : "10579000",					// 체결 가격
        //                 "contQty" : "0.01",							// 체결 수량
        //                 "contAmt" : "105790.00",					// 체결 금액
        //                 "contDtm" : "2020-01-29 12:24:18.830039",	// 체결 시각
        //                 "updn" : "dn"								// 직전 시세와 비교 : up-상승, dn-하락
        //             }
        //         ]
        //     }
        // }
        const content = this.safeValue(message, "content");
        const list = this.safeValue(content, 'list', []);
        if (list.length === 0) {
            return false;
        }
        const marketId = this.safeString(list[0], 'symbol').replace('_KRW', '');
        const symbol = this.safeSymbol(marketId);
        const trades = this.parseTrades(list);
        const messageHash = 'transaction:' + marketId;
        let stored = this.safeValue(this.trades, symbol);
        if (stored === undefined) {
            const limit = this.safeInteger(this.options, 'tradesLimit', 1000);
            stored = new ArrayCache(limit);
            this.trades[symbol] = stored;
        }
        for (let i = 0; i < trades.length; i++) {
            stored.append(trades[i]);
        }
        client.resolve(stored, messageHash);
    }
    parseTrade(trade, market = undefined) {
        // {
        //     "symbol" : "BTC_KRW",					// 통화 코드
        //     "buySellGb" : "1",							// 체결 종류(1:매도체결, 2:매수체결)
        //     "contPrice" : "10579000",					// 체결 가격
        //     "contQty" : "0.01",							// 체결 수량
        //     "contAmt" : "105790.00",					// 체결 금액
        //     "contDtm" : "2020-01-29 12:24:18.830039",	// 체결 시각
        //     "updn" : "dn"								// 직전 시세와 비교 : up-상승, dn-하락
        // }
        let timestamp = undefined;
        const transactionDatetime = this.safeString(trade, 'contDtm');
        if (transactionDatetime !== undefined) {
            timestamp = this.parse8601(transactionDatetime)
        }
        if (timestamp !== undefined) {
            timestamp -= 9 * 3600000; // they report UTC + 9 hours, server in Korean timezone
        }
        const type = undefined;
        let buySellGb = this.safeInteger(trade, 'buySellGb');
        const side = (buySellGb === 1) ? 'sell' : 'buy';
        const id = this.safeString(trade, 'cont_no');
        const marketId = this.safeString(trade, 'symbol').replace('_KRW', '');
        const symbol = this.safeSymbol(marketId);
        const priceString = this.safeString(trade, 'contPrice');
        const amountString = this.safeString(trade, 'contQty');
        const costString = this.safeString(trade, 'total');
        return this.safeTrade({
            'id': id,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601(timestamp),
            'symbol': symbol,
            'order': undefined,
            'type': type,
            'side': side,
            'takerOrMaker': undefined,
            'price': priceString,
            'amount': amountString,
            'cost': costString,
            'fee': undefined,
        }, market);
    }
    handleStatus(client, message) {
        //
        //     {
        //          "status" : "0000",
        //          "resmsg" : "success"
        //     }
        //
        const status = this.safeString(message, 'status');
        if (status !== '0000') {
            try {
                const feedback = this.id + ' ' + this.json(message);
                this.throwExactlyMatchedException(this.exceptions['exact'], status, feedback);
                const messageString = this.safeValue(message, 'msg');
                if (messageString !== undefined) {
                    this.throwBroadlyMatchedException(this.exceptions['broad'], messageString, feedback);
                }
                throw new ExchangeError(feedback);
            }
            catch (e) {
                client.reject(e);
            }
        }
        client.resolve(message, 'status');
        return message;
    }
    handleMessage(client, message) {
        const status = this.safeString(message, 'status');
        if (status === '0000') {
            return this.handleStatus(client, message);
        }
        const methods = {
            'ticker': this.handleTicker,
            'orderbooksnapshot': this.handleOrderBookSnapshot,
            'orderbookdepth': this.handleOrderBook,
            'transaction': this.handleTrades,
        };
        const methodName = this.safeString(message, 'type');
        const method = this.safeValue(methods, methodName);
        if (method) {
            method.call(this, client, message);
        }
    }
}
