// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code
// EDIT THE CORRESPONDENT .ts FILE INSTEAD

//@ts-nocheck
/*  ------------------------------------------------------------------------ */
import { now, sleep } from './time.js';
/*  ------------------------------------------------------------------------ */
class Throttler {
    constructor(config) {
        this.config = {
            'refillRate': 1.0,
            'delay': 0.001,
            'capacity': 1.0,
            'maxCapacity': 2000,
            'tokens': {
                'default': 0
            },
            'cost': 1.0,
        };
        Object.assign(this.config, config);
        this.queue = {
            'default': []
        };
        this.running = {
            'default': false
        };
    }
    async loop(api_rate_limit_group) {
        let lastTimestamp = now();
        while (this.running[api_rate_limit_group]) {
            const { resolver, cost } = this.queue[api_rate_limit_group][0];
            if (this.config['tokens'][api_rate_limit_group] >= 0) {
                this.config['tokens'][api_rate_limit_group] -= cost;
                resolver();
                this.queue[api_rate_limit_group].shift();
                // contextswitch
                await Promise.resolve();
                if (this.queue[api_rate_limit_group].length === 0) {
                    this.running[api_rate_limit_group] = false;
                }
            }
            else {
                await sleep(this.config['delay'] * 1000);
                const current = now();
                const elapsed = current - lastTimestamp;
                lastTimestamp = current;
                const tokens = this.config['tokens'][api_rate_limit_group] + (this.config['refillRate'] * elapsed);
                this.config['tokens'][api_rate_limit_group] = Math.min(tokens, this.config['capacity']);
            }
        }
    }
    throttle(cost = undefined, config = {}) {
        let resolver, api_rate_limit_group;
        const promise = new Promise((resolve, reject) => {
            resolver = resolve;
        });
        if (config['api_rate_limit_group'] !== undefined) {
            api_rate_limit_group = config['api_rate_limit_group'];
        } else {
            api_rate_limit_group = 'default';
        }
        if (this.queue[api_rate_limit_group] === undefined) {
            this.queue[api_rate_limit_group] = [];
            this.running[api_rate_limit_group] = false;
            this.config['tokens'][api_rate_limit_group] = 0;
        }
        if (this.queue[api_rate_limit_group].length > this.config['maxCapacity']) {
            throw new Error('throttle queue [' + api_rate_limit_group + '] is over maxCapacity (' + this.config['maxCapacity'].toString() + '), see https://github.com/ccxt/ccxt/issues/11645#issuecomment-1195695526');
        }
        cost = (cost === undefined) ? this.config['cost'] : cost;
        this.queue[api_rate_limit_group].push({ resolver, cost });
        if (!this.running[api_rate_limit_group]) {
            this.running[api_rate_limit_group] = true;
            this.loop(api_rate_limit_group);
        }
        return promise;
    }
}
export { Throttler, };
// ----------------------------------------